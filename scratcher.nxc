#include "motcont/MotorControl22.nxc"

// #define LOGGING
#include "logging.nxc"

struct point {
    float x;
    float y;
    float z;
};

struct radii {
    float r1;
    float r2;
    float r3;
};

// The wheel has a circumference of 6 cm averaged over 10 turns.
// The diameter of 1.9 agrees with the result.
// 1 cm = 60 degrees
const float CM = 60;

// From http://en.wikipedia.org/wiki/Trilateration
// Motor A is 0, 0, 0
// Motor B is 0, D, 0
// Motor C is I, J, 0
// Or, D is the length of a side of the triangle in cm.
// J is also the height of the triangle.
const float D = 46.0;
const float I = D / 2;
const float J = 0.866 * D;

radii INITIAL_RADII;
const int POWER = 60;
const bool SPEEDREG = false;
const bool SMOOTHSTART = true;
const bool HOLDBRAKE = true;


point radii_to_cartesian(radii input) {
    point output;
    output.x = (pow(input.r1, 2) - pow(input.r2, 2) + pow(D, 2)) / (2 * D);
    output.y = ((pow(input.r1, 2) - pow(input.r3, 2) + pow(I, 2) + pow(J, 2)) / (2 * J)) - ((I * output.x) / J);
    output.z = sqrt(abs(pow(input.r1, 2) - pow(output.x, 2) - pow(output.y, 2)));
    return output;
}

radii cartesian_to_radii(point input) {
    radii output;
    output.r1 = sqrt(pow(input.x, 2) + pow(input.y, 2) + pow(input.z, 2));
    output.r2 = sqrt(pow((input.x - D), 2) + pow(input.y, 2) + pow(input.z, 2));
    output.r3 = sqrt(pow((input.x - I), 2) + pow((input.y - J), 2) + pow(input.z, 2));
    return output;
}

float ensure_in_triangle(point input) {
    // Ensure that a given point falls inside a triangle.

    // The slope of an equilateral triangle is tan(60). We can check if the
    // point lies inside the triangle with one equation by transposing the
    // triangle D / 2 to the left and checking to see if the point falls
    // inside the half-triangle.
    float triangle_y = -1.732 * abs(input.x - D / 2) + J;
    if (triangle_y < input.y)
        return triangle_y;
    else
        return input.y;
}

void init_radii() {
    // Place the scratcher 5 cm under motor A.
    point initial;
    initial.x = 0;
    initial.y = 0;
    initial.z = 5;

    INITIAL_RADII = cartesian_to_radii(initial);
}

void init_buttons() {
    // Initialize the button press counts.
    SetButtonPressCount(BTNCENTER, 0);
    SetButtonPressCount(BTNLEFT, 0);
    SetButtonPressCount(BTNRIGHT, 0);
}

void init_motors() {
    // Initialize the motcont motors.
    InitSpeedFromPosLUT();

    motorParamsA.power = POWER;
    motorParamsA.tacholimit = 1000;
    motorParamsA.speedreg = SPEEDREG;
    motorParamsA.holdbrake = HOLDBRAKE;
    motorParamsA.smoothstart = SMOOTHSTART;

    motorParamsB.power = POWER;
    motorParamsB.tacholimit = 1000;
    motorParamsB.speedreg = SPEEDREG;
    motorParamsB.holdbrake = HOLDBRAKE;
    motorParamsB.smoothstart = SMOOTHSTART;

    motorParamsC.power = POWER;
    motorParamsC.tacholimit = 1000;
    motorParamsC.speedreg = SPEEDREG;
    motorParamsC.holdbrake = HOLDBRAKE;
    motorParamsC.smoothstart = SMOOTHSTART;
}

void wait_for_motors() {
    // Wait for all the motors to stop moving.

    while(taskArunning) {
        Wait(50);
    }

    while(taskBrunning) {
        Wait(50);
    }

    while(taskCrunning) {
        Wait(50);
    }
}

void move_to_radius(const byte &port, float radius) {
    // Move to the given (absolute) radius.

    long degrees = radius * CM;
    int powersign = 1;


    // Subtract the motor's current position from the desired one to get
    // the absolute position.
    degrees = degrees - MotorBlockTachoCount(port);

    if (degrees < 0) {
        degrees = abs(degrees);
        powersign = -1;
    }

    // Move to that position.
    switch(port) {
        case OUT_A:
            motorParamsA.power = powersign * POWER;
            motorParamsA.tacholimit = degrees;
            taskArunning = true;
            start MoveA;
            break;
        case OUT_B:
            motorParamsB.power = powersign * POWER;
            motorParamsB.tacholimit = degrees;
            taskBrunning = true;
            start MoveB;
            break;
        case OUT_C:
            motorParamsC.power = powersign * POWER;
            motorParamsC.tacholimit = degrees;
            taskCrunning = true;
            start MoveC;
            break;
    }
}

void move_to_radii(radii input) {
    // Move to the given radii, relative to the starting position.

    // Subtract the new position from the initial position. Since the software
    // doesn't know we're at some point (x, y, z) to begin with, it treats the
    // starting position as (0, 0, 0). The calculation here compensates for that.
    input.r1 = input.r1 - INITIAL_RADII.r1;
    input.r2 = input.r2 - INITIAL_RADII.r2;
    input.r3 = input.r3 - INITIAL_RADII.r3;


    ResetScreen();
    TextOut(0, LCD_LINE1, "Moving to:");
    NumOut(0, LCD_LINE2, input.r1);
    NumOut(0, LCD_LINE3, input.r2);
    NumOut(0, LCD_LINE4, input.r3);

    // Move.
    move_to_radius(OUT_A, input.r1);
    move_to_radius(OUT_B, input.r2);
    move_to_radius(OUT_C, input.r3);

    // Wait for all the motors to stop moving.
    wait_for_motors();
}

void move_to(point input) {
    // Make sure the point is inside the triangle by forcing it.
    input.y = ensure_in_triangle(input);

    // Sanity check.
    if (input.z < 5)
        input.z = 5;

    writeLogValue3("Moving to position", input.x, input.y, input.z);

    // Move to the specified Cartesian point.
    radii target = cartesian_to_radii(input);

    writeLogValue3("Moving to radii", target.r1, target.r2, target.r3);

    move_to_radii(target);
}

void reset() {
    // Move back to the origin.
    move_to_radii(INITIAL_RADII);
}

task main() {
    point target;

    openLogFile("scratcher.log", 5000);
    init_radii();
    init_motors();
    init_buttons();

    while (true) {
        // Exit gracefully if the center button is pressed.
        if (ButtonPressCount(BTNCENTER) > 0)
            break;

        // Right button lowers, left button raises.
        target.x = Random(J);
        target.y = Random(J);
        target.z = 20 + ButtonPressCount(BTNRIGHT) - ButtonPressCount(BTNLEFT);

        move_to(target);
    }

    ResetScreen();
    TextOut(0, LCD_LINE1, "Resetting...");
    reset();
    closeLogFile();
}
